library(MASS)
library(ggplot2)
library(tidyverse)
raw_df = read.csv('Data/ken6hrs.csv')
df = subset(raw_df, select = c(Frame,Tracking.ID,Integrated.Intensity,Dry.Mass,Position.X, Position.Y))
df$Normalized_Intensity = df$Integrated.Intensity/df$Dry.Mass
df <- df %>%
group_by(Tracking.ID) %>%
mutate(Normalized_Intensity_Next_Change = lead(Normalized_Intensity) - Normalized_Intensity,
Normalized_Intensity_Prev_Change = Normalized_Intensity - lag(Normalized_Intensity))
calculate_correction <- function(center, radius, rect) {
x <- center[1]
y <- center[2]
min_x <- rect[1]
max_x <- rect[2]
min_y <- rect[3]
max_y <- rect[4]
circle_area <- pi * radius^2
# Check if the circle is fully inside the rectangle
if (x - radius >= min_x && x + radius <= max_x &&
y - radius >= min_y && y + radius <= max_y) {
return(circle_area)
}
# Estimate the overlap area (this is a simplified estimation)
overlap_area <- circle_area
if (x - radius < min_x) {
overlap_area <- overlap_area - pi * (radius - (x - min_x))^2 / 4
}
if (x + radius > max_x) {
overlap_area <- overlap_area - pi * (radius - (max_x - x))^2 / 4
}
if (y - radius < min_y) {
overlap_area <- overlap_area - pi * (radius - (y - min_y))^2 / 4
}
if (y + radius > max_y) {
overlap_area <- overlap_area - pi * (radius - (max_y - y))^2 / 4
}
return(overlap_area)
}
gaussian <- function(distance, sigma){
exp(-(distance^2)/(2*(sigma^2)))
}
calculate_crowding <- function(df, sigmas, window_width = 1000, new_column_names) {
if (length(new_column_names) != length(sigmas)) {
stop("Length of 'new_column_names' must match length of 'sigmas'")
}
for (i in seq_along(sigmas)) {
sigma <- sigmas[i]
new_column_name <- new_column_names[i]
df <- df %>%
group_by(Frame) %>%
mutate(!!new_column_name := sapply(1:n(), function(i) {
center <- c(Position.X[i], Position.Y[i])
radius <- sigma  # Example: Adjust based on sigma
rect <- c(0, window_width, 0, window_width)  # Assuming rectangular frame
correction_factor <- (pi * radius^2) / calculate_correction(center, radius, rect)
# Calculate distances from the current center
distances <- sqrt((Position.X - Position.X[i])^2 + (Position.Y - Position.Y[i])^2)
# Filter out the center row (i-th row) and apply the Gaussian to the other rows
gaussian_values <- gaussian(distances, sigma = sigma)
# Multiply Gaussian values by the 'Normalized_Intensity', excluding the center
non_center_indices <- setdiff(1:n(), i)
crowding_effect <- sum(gaussian_values[non_center_indices]* Normalized_Intensity_Prev_Change[non_center_indices]) * correction_factor
return(crowding_effect)
}))
}
return(df)
}
df <- df%>%
drop_na(Normalized_Intensity_Prev_Change)
sigmas = c(50,100,150,200,250)
crowding_cols = c("Crowding_50", "Crowding_100", "Crowding_150", "Crowding_200", "Crowding_250")
df = calculate_crowding(df,sigmas, new_column_names = crowding_cols)
df_next_clean <- df%>%
drop_na(Normalized_Intensity_Next_Change)
create_smoothed_plot <- function(x_col_name, y_col_name,df) {
# Apply the supsmu function
smooth_data <- supsmu(df[[x_col_name]], df[[y_col_name]])
# Create the plot
plot <- ggplot(df, aes_string(x = x_col_name, y = y_col_name)) +
geom_point() +  # Scatter plot
geom_line(aes(x = smooth_data$x, y = smooth_data$y), color = "blue") +  # Smoothed line
labs(
title = paste("Scatter Plot with Smoothed Line using supsmu for", x_col_name),
x = paste(x_col_name),
y = paste(y_col_name)
)
# Print the plot
print(plot)
}
lm_analyze_intervals <- function(df, x_cols, y_col, interval_size = 30) {
# Determine the range of the Frame column
frame_min <- min(df$Frame)
frame_max <- max(df$Frame)
# Define the intervals
intervals <- seq(frame_min, frame_max + interval_size, by = interval_size)
p_values <- c()
x_coefficients <- c()
interval_labels <- c()
crowding_cols <- c()
for (i in 1:(length(intervals) - 1)) {
interval_start <- intervals[i]
interval_end <- intervals[i + 1]
# Subset the data for the current interval
df_subset <- df[df$Frame >= interval_start & df$Frame < interval_end, ]
for (x_col in x_cols) {
fit <- lm(df_subset[[y_col]] ~ df_subset[[x_col]])
fit_info <- summary(fit)$coefficients
x_coefficients <- append(x_coefficients, fit_info[2, 1])  # Coefficient
p_values <- append(p_values, fit_info[2, 4])  # p-value
interval_labels <- append(interval_labels, paste(interval_start, interval_end, sep = "-"))
crowding_cols <- append(crowding_cols, x_col)
}
}
# Create the results data frame
linear_model_df <- data.frame(interval_labels, crowding_cols, x_coefficients, p_values)
return(linear_model_df)
}
plot_lm_interval_results <- function(linear_model_df) {
# Convert interval_labels to a factor with the specified order
interval_order <- unique(linear_model_df$interval_labels)
linear_model_df$interval_labels <- factor(linear_model_df$interval_labels, levels = interval_order)
# Create a new column for shape categories
linear_model_df$shape_category <- cut(linear_model_df$p_values,
breaks = c(-Inf, 0.001, 0.05, Inf),
labels = c("p<0.001", "0.001<p<0.05", "p>0.05"))
# Create the scatter plot with shape mapped to the shape categories
scatter_plot <- ggplot(linear_model_df, aes(x = interval_labels, y = x_coefficients, color = crowding_cols, shape = shape_category)) +
geom_point(size = 3) +  # You can adjust the size of the points if needed
labs(x = "Frame Intervals", y = "Coefficients", color = "Crowding Columns", shape = "P-Value Category") +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +  # Rotate x-axis labels if needed
theme_minimal() +
scale_shape_manual(values = c("p<0.001" = 16, "0.001<p<0.05" = 8, "p>0.05" = 4))  # Adjust the shapes as needed
# Print the scatter plot
print(scatter_plot)
}
# Loop through each x column and create the plot
for (x_col in crowding_cols) {
create_smoothed_plot(x_col, "Normalized_Intensity",df)
}
p_values = c()
x_coefficients = c()
r_squares = c()
for(x_col in crowding_cols){
fit = lm(df$Normalized_Intensity ~ df[[x_col]])
fit_info = (summary(fit)$coefficients)
x_coefficients <- append(x_coefficients, fit_info[2])
p_values <- append(p_values, fit_info[8])
r_squares <- append(r_squares, summary(fit)$r.squared)
}
int_change_lm_df = data.frame(crowding_cols, x_coefficients, p_values, r_squares)
print(int_change_lm_df)
linear_model_df = lm_analyze_intervals(df, crowding_cols, "Normalized_Intensity")
plot_lm_interval_results(linear_model_df)
for (x_col in crowding_cols) {
create_smoothed_plot(x_col, "Normalized_Intensity_Next_Change", df_next_clean)
}
p_values = c()
x_coefficients = c()
r_squares = c()
for(x_col in crowding_cols){
fit = lm(df$Normalized_Intensity_Next_Change ~ df[[x_col]])
fit_info = (summary(fit)$coefficients)
x_coefficients <- append(x_coefficients, fit_info[2])
p_values <- append(p_values, fit_info[8])
r_squares <- append(r_squares, summary(fit)$r.squared)
}
int_change_lm_df = data.frame(crowding_cols, x_coefficients, p_values, r_squares)
print(int_change_lm_df)
Int_Change_lmi_df = lm_analyze_intervals(df_next_clean, crowding_cols, "Normalized_Intensity_Next_Change")
plot_lm_interval_results(Int_Change_lmi_df)
df <- df %>%
mutate(across(all_of(crowding_cols), ~ . * Normalized_Intensity, .names = "{col}_Weighted"))
df_next_clean <- df%>%
drop_na(Normalized_Intensity_Next_Change)
weighted_crowding_cols <- c("Crowding_50_Weighted", "Crowding_100_Weighted", "Crowding_150_Weighted", "Crowding_200_Weighted", "Crowding_250_Weighted")
# Loop through each x column and create the plot
for (x_col in weighted_crowding_cols) {
create_smoothed_plot(x_col, "Normalized_Intensity", df)
}
p_values = c()
x_coefficients = c()
r_squares = c()
for(x_col in weighted_crowding_cols){
fit = lm(df$Normalized_Intensity ~ df[[x_col]])
fit_info = (summary(fit)$coefficients)
x_coefficients <- append(x_coefficients, fit_info[2])
p_values <- append(p_values, fit_info[8])
r_squares <- append(r_squares, summary(fit)$r.squared)
}
int_change_lm_df = data.frame(crowding_cols, x_coefficients, p_values, r_squares)
print(int_change_lm_df)
weighted_lm_df = lm_analyze_intervals(df, weighted_crowding_cols, "Normalized_Intensity")
plot_lm_interval_results(weighted_lm_df)
for (x_col in weighted_crowding_cols) {
create_smoothed_plot(x_col, "Normalized_Intensity_Next_Change", df_next_clean)
}
p_values = c()
x_coefficients = c()
r_squares = c()
for(x_col in weighted_crowding_cols){
fit = lm(df_next_clean$Normalized_Intensity_Next_Change ~ df_next_clean[[x_col]])
fit_info = (summary(fit)$coefficients)
x_coefficients <- append(x_coefficients, fit_info[2])
p_values <- append(p_values, fit_info[8])
r_squares <- append(r_squares, summary(fit)$r.squared)
}
int_change_lm_df = data.frame(crowding_cols, x_coefficients, p_values, r_squares)
print(int_change_lm_df)
weighted_change_lm_df = lm_analyze_intervals(df_next_clean, weighted_crowding_cols, "Normalized_Intensity_Next_Change")
plot_lm_interval_results(weighted_change_lm_df)
df_clean = na.omit(df)
df_clean <- df_clean %>%
mutate(across(all_of(crowding_cols), ~ . * Normalized_Intensity_Prev_Change, .names = "{col}_Change_Weighted"))
change_weighted_crowding_cols <- c("Crowding_50_Change_Weighted", "Crowding_100_Change_Weighted", "Crowding_150_Change_Weighted", "Crowding_200_Change_Weighted", "Crowding_250_Change_Weighted")
for (x_col in change_weighted_crowding_cols) {
create_smoothed_plot(x_col, "Normalized_Intensity_Next_Change", df_clean)
}
p_values = c()
x_coefficients = c()
r_squares = c()
for(x_col in change_weighted_crowding_cols){
fit = lm(df_clean$Normalized_Intensity_Next_Change ~ df_clean[[x_col]])
fit_info = (summary(fit)$coefficients)
x_coefficients <- append(x_coefficients, fit_info[2])
p_values <- append(p_values, fit_info[8])
r_squares <- append(r_squares, summary(fit)$r.squared)
}
int_change_lm_df = data.frame(crowding_cols, x_coefficients, p_values, r_squares)
print(int_change_lm_df)
weighted_lm_df = lm_analyze_intervals(df_clean, change_weighted_crowding_cols, "Normalized_Intensity_Next_Change")
plot_lm_interval_results(weighted_lm_df)
#parameters
hot_heat = 2
cold_heat = 1
step_size = 0.1
hot_size = 10
cold_size = 0
left_x = 0
right_x = 1000
hot_data = data.frame(
pos_x = seq(0,1000, length.out = hot_size),
heat = rep(hot_heat,hot_size)
)
cold_data = data.frame(
pos_x = seq(0,1000, length.out = cold_size),
heat = rep(cold_heat,cold_size)
)
## combine data
cancer_pos = rbind(hot_data, cold_data)
#k: chemokine decay constant
k = 0.2
#d: chemokine diffusion constant
d = 100
#M: heat of cancer cell
#x: distance from cancer cell to current x position
calculate_diffusion_1d <- function(k, d, m, x) {
ifelse(x < 0,
(m / (2 * sqrt(d * k))) * exp(x * sqrt(k / d)),
(m / (2 * sqrt(d * k))) * exp(-x * sqrt(k / d)))
}
chemokine_x_positions = seq(from=left_x, to=right_x, by = step_size)
chemokine_concentration = numeric(length(x_positions))
for (row in 1:nrow(cancer_pos)) {
y <- calculate_diffusion_1d(k = k, d = d, m = cancer_pos[row, "heat"], x = (chemokine_x_positions - cancer_pos[row, "pos_x"]))
chemokine_concentration = chemokine_concentration + y # why do i add here?
}
chemokine_gradient = data.frame(x_pos = x_positions, concentration = chemokine_concentration)
## parameters
stoch = 1
chemokine_concentration = numeric(length(x_positions))
chemokine_concentration = numeric(length(chemokine_x_positions))
for (row in 1:nrow(cancer_pos)) {
y <- calculate_diffusion_1d(k = k, d = d, m = cancer_pos[row, "heat"], x = (chemokine_x_positions - cancer_pos[row, "pos_x"]))
chemokine_concentration = chemokine_concentration + y # why do i add here?
}
chemokine_gradient = data.frame(x_pos = x_positions, concentration = chemokine_concentration)
chemokine_gradient = data.frame(x_pos = chemokine_x_positions, concentration = chemokine_concentration)
chemokine_gradient$concentration[chemokine_gradient$x_pos == 101.1, ]
chemokine_gradient$concentration[chemokine_gradient$x_pos == 101.1]
chemokine_gradient$concentration[chemokine_gradient$x_pos == 0.0]
chemokine_gradient$concentration[chemokine_gradient$x_pos == 100]
chemokine_gradient$concentration[chemokine_gradient$x_pos == 101.1]
chemokine_gradient$concentration[chemokine_gradient$x_pos == 101.2]
chemokine_gradient$concentration[chemokine_gradient$x_pos == 101.5]
source("C:/Users/Tony Zhang/OneDrive/Documents/Fall-2024 Semester/UROP/TumorDataModel_Reimp.R", echo=TRUE)
tcell_df = run_sim(tcell_df)
run_sim <- function(agents){
for (i in 1:iterations){
previous_frame <- max(agents$frame)
next_frame <- previous_frame + 1
if (next_frame <= iterations){
previous_frame_agents <- agents[agents$frame == previous_frame,]
next_frame_agents <- data.frame(matrix(ncol = length(column_names), nrow = 0))
colnames(next_frame_agents) <- column_names
for (id in 1:num_tcells){
previous_frame_agent <- previous_frame_agents[previous_frame_agents$id == id,]
previous_pos_x <- previous_frame_agent$pos_x
# Get concentration to right
previous_pos_x_right <- previous_pos_x + step
previous_sum_conc_right <- chemokine_gradient$concentration[chemokine_gradient$x_pos == previous_pos_x_right]
# Get concentration to left
previous_pos_x_left <- previous_pos_x - step
previous_sum_conc_left <- chemokine_gradient$concentration[chemokine_gradient$x_pos == previous_pos_x_left]
delta_x <- get_next_step(previous_sum_conc_left, previous_sum_conc_right)
new_pos_x <- previous_pos_x + delta_x
if (new_pos_x < left_x){
new_pos_x = right_x
}else if(right_x < new_pos_x){
new_pos_x = left_x
}
next_agent <- data.frame(
id = id,
frame = next_frame,
pos_x = new_pos_x,
pos_y = chemokine_gradient$concentration[chemokine_gradient$x_pos == new_pos_x],
)
next_frame_agents <- rbind(next_frame_agents, next_agent)
}
agents <- rbind(agents, next_frame_agents)
}
}
return(agents)
}
tcell_df = run_sim(tcell_df)
# Get concentration to right
previous_pos_x_right <- previous_pos_x + step_size
run_sim <- function(agents){
for (i in 1:iterations){
previous_frame <- max(agents$frame)
next_frame <- previous_frame + 1
if (next_frame <= iterations){
previous_frame_agents <- agents[agents$frame == previous_frame,]
next_frame_agents <- data.frame(matrix(ncol = length(column_names), nrow = 0))
colnames(next_frame_agents) <- column_names
for (id in 1:num_tcells){
previous_frame_agent <- previous_frame_agents[previous_frame_agents$id == id,]
previous_pos_x <- previous_frame_agent$pos_x
# Get concentration to right
previous_pos_x_right <- previous_pos_x + step_size
previous_sum_conc_right <- chemokine_gradient$concentration[chemokine_gradient$x_pos == previous_pos_x_right]
# Get concentration to left
previous_pos_x_left <- previous_pos_x - step_size
previous_sum_conc_left <- chemokine_gradient$concentration[chemokine_gradient$x_pos == previous_pos_x_left]
delta_x <- get_next_step(previous_sum_conc_left, previous_sum_conc_right)
new_pos_x <- previous_pos_x + delta_x
if (new_pos_x < left_x){
new_pos_x = right_x
}else if(right_x < new_pos_x){
new_pos_x = left_x
}
next_agent <- data.frame(
id = id,
frame = next_frame,
pos_x = new_pos_x,
pos_y = chemokine_gradient$concentration[chemokine_gradient$x_pos == new_pos_x],
)
next_frame_agents <- rbind(next_frame_agents, next_agent)
}
agents <- rbind(agents, next_frame_agents)
}
}
return(agents)
}
tcell_df=run_sim(tcell_df)
get_next_step(25,50)
get_next_step(25,100)
get_next_step(25,150)
get_next_step(25,1)
get_next_step(25,25)
get_next_step(25,26)
get_next_step(25,26)
get_next_step(25,26)
get_next_step(25,26)
get_next_step(25,26)
get_next_step(25,26)
get_next_step(25,26)
get_next_step(25,26)
get_next_step(25,26)
get_next_step(25,26)
get_next_step(25,26)
get_next_step(25,26)
get_next_step(25,26)
get_next_step(25,26)
get_next_step(25,26)
get_next_step(25,26)
#function which returns the next movement in which the cell will move
get_next_step <- function(left_conc, right_conc){
print(left_conc)
print(right_conc)
higher_conc_direction = ifelse(right_conc>left_conc,
1,
-1)
#calculates the probablity that a cell will move in the direction with a higher concentration
prob_move_higher_conc = 1 / (1 + exp(-1 * stoch * abs(left_conc - right_conc)))
rand_num = runif(1)
#if randomly generated number is less than probablity move in direction of higher concentration else move in opposite direction
if(rand_num < prob_move_higher_conc){
return(step_size * higher_conc_direction)
}else{
return(step_size * (-1 * higher_conc_direction))
}
}
tcell_df=run_sim(tcell_df)
next_frame_agents <- data.frame(matrix(ncol = length(column_names), nrow = 0))
source("C:/Users/Tony Zhang/OneDrive/Documents/Fall-2024 Semester/UROP/TumorDataModel_Reimp.R", echo=TRUE)
tcell_df=run_sim(tcell_df)
source("C:/Users/Tony Zhang/OneDrive/Documents/Fall-2024 Semester/UROP/TumorDataModel_Reimp.R", echo=TRUE)
tcell_df =run_sim(tcell_df)
View(tcell_df)
source("C:/Users/Tony Zhang/OneDrive/Documents/Fall-2024 Semester/UROP/TumorDataModel_Reimp.R", echo=TRUE)
plot(chemokine_gradient$x_pos, chemokine_gradient$concentration, type ='l')
source("C:/Users/Tony Zhang/OneDrive/Documents/Fall-2024 Semester/UROP/TumorDataModel_Reimp.R", echo=TRUE)
plot(chemokine_gradient$x_pos, chemokine_gradient$concentration, type ='l')
source("C:/Users/Tony Zhang/OneDrive/Documents/Fall-2024 Semester/UROP/TumorDataModel_Reimp.R", echo=TRUE)
plot(chemokine_gradient$x_pos, chemokine_gradient$concentration)
source("C:/Users/Tony Zhang/OneDrive/Documents/Fall-2024 Semester/UROP/TumorDataModel_Reimp.R", echo=TRUE)
plot(chemokine_gradient$x_pos, chemokine_gradient$concentration, type ='l')
library(ggplot2)
library(dplyr)
library(gridExtra)
raw_df = read.csv("data/20240619_624Mel_MIZ_DAB_B2_8_Phase-FullFeatureTable.csv")
cell_id = 1
df_filtered = raw_df[raw_df$Tracking.ID == cell_id, ]
plot_drymass <- ggplot(df_filtered, aes(x = Frame, y = Dry.Mass)) +
geom_line(color = "blue") +
labs(title = paste("Dry Mass for Cell ID", cell_id), y = "Dry Mass")
plot_track_length <- ggplot(df_filtered, aes(x = Frame, y = Instantaneous.Velocity)) +
geom_line(color = "green") +
labs(title = paste("Velocity for Cell ID", cell_id), y = "Velocity")
plot_velocity <- ggplot(df_filtered, aes(x = Frame, y = Mean.Thickness)) +
geom_line(color = "red") +
labs(title = paste("Velocity for Cell ID", cell_id), y = "Velocity", x = "Frame")
# Arrange the plots in a grid
grid.arrange(plot_drymass, plot_track_length, plot_velocity, ncol = 1)
cell_id = 9
df_filtered = raw_df[raw_df$Tracking.ID == cell_id, ]
plot_drymass <- ggplot(df_filtered, aes(x = Frame, y = Dry.Mass)) +
geom_line(color = "blue") +
labs(title = paste("Dry Mass for Cell ID", cell_id), y = "Dry Mass")
plot_track_length <- ggplot(df_filtered, aes(x = Frame, y = Instantaneous.Velocity)) +
geom_line(color = "green") +
labs(title = paste("Velocity for Cell ID", cell_id), y = "Velocity")
plot_velocity <- ggplot(df_filtered, aes(x = Frame, y = Mean.Thickness)) +
geom_line(color = "red") +
labs(title = paste("Velocity for Cell ID", cell_id), y = "Velocity", x = "Frame")
# Arrange the plots in a grid
grid.arrange(plot_drymass, plot_track_length, plot_velocity, ncol = 1)
cell_id = 175
df_filtered = raw_df[raw_df$Tracking.ID == cell_id, ]
plot_drymass <- ggplot(df_filtered, aes(x = Frame, y = Dry.Mass)) +
geom_line(color = "blue") +
labs(title = paste("Dry Mass for Cell ID", cell_id), y = "Dry Mass")
plot_track_length <- ggplot(df_filtered, aes(x = Frame, y = Instantaneous.Velocity)) +
geom_line(color = "green") +
labs(title = paste("Velocity for Cell ID", cell_id), y = "Velocity")
plot_velocity <- ggplot(df_filtered, aes(x = Frame, y = Mean.Thickness)) +
geom_line(color = "red") +
labs(title = paste("Velocity for Cell ID", cell_id), y = "Velocity", x = "Frame")
# Arrange the plots in a grid
grid.arrange(plot_drymass, plot_track_length, plot_velocity, ncol = 1)
cell_id = 72
df_filtered = raw_df[raw_df$Tracking.ID == cell_id, ]
plot_drymass <- ggplot(df_filtered, aes(x = Frame, y = Dry.Mass)) +
geom_line(color = "blue") +
labs(title = paste("Dry Mass for Cell ID", cell_id), y = "Dry Mass")
plot_track_length <- ggplot(df_filtered, aes(x = Frame, y = Instantaneous.Velocity)) +
geom_line(color = "green") +
labs(title = paste("Velocity for Cell ID", cell_id), y = "Velocity")
plot_velocity <- ggplot(df_filtered, aes(x = Frame, y = Mean.Thickness)) +
geom_line(color = "red") +
labs(title = paste("Velocity for Cell ID", cell_id), y = "Velocity", x = "Frame")
# Arrange the plots in a grid
grid.arrange(plot_drymass, plot_track_length, plot_velocity, ncol = 1)
cell_id = 72
df_filtered = raw_df[raw_df$Tracking.ID == cell_id, ]
plot_drymass <- ggplot(df_filtered, aes(x = Frame, y = Dry.Mass)) +
geom_line(color = "blue") +
labs(title = paste("Dry Mass for Cell ID", cell_id), y = "Dry Mass")
plot_track_length <- ggplot(df_filtered, aes(x = Frame, y = Instantaneous.Velocity)) +
geom_line(color = "green") +
labs(title = paste("Velocity for Cell ID", cell_id), y = "Velocity")
plot_velocity <- ggplot(df_filtered, aes(x = Frame, y = Mean.Thickness)) +
geom_line(color = "red") +
labs(title = paste("Mean Thickness for Cell ID", cell_id), y = "Mean Thickness (um)", x = "Frame")
# Arrange the plots in a grid
grid.arrange(plot_drymass, plot_track_length, plot_velocity, ncol = 1)
cell_id = 72
df_filtered = raw_df[raw_df$Tracking.ID == cell_id, ]
plot_drymass <- ggplot(df_filtered, aes(x = Frame, y = Dry.Mass)) +
geom_line(color = "blue") +
labs(title = paste("Dry Mass for Cell ID", cell_id), y = "Dry Mass")
plot_velocity <- ggplot(df_filtered, aes(x = Frame, y = Instantaneous.Velocity)) +
geom_line(color = "green") +
labs(title = paste("Velocity for Cell ID", cell_id), y = "Velocity")
plot_thickness <- ggplot(df_filtered, aes(x = Frame, y = Mean.Thickness)) +
geom_line(color = "red") +
labs(title = paste("Mean Thickness for Cell ID", cell_id), y = "Mean Thickness (um)", x = "Frame")
# Arrange the plots in a grid
grid.arrange(plot_drymass, plot_thickness, plot_velocity, ncol = 1)
library(ggplot2)
library(dplyr)
library(gridExtra)
raw_df = read.csv("data/20240619_624Mel_MIZ_DAB_B2_8_Phase-FullFeatureTable.csv")
?optim
source("C:/Users/Tony Zhang/source/repos/UROP/ChemokineGradientSim/TumorDataModel_Reimp.R", echo=TRUE)
setwd("C:/Users/Tony Zhang/source/repos/UROP/ChemokineGradientSim")
source("C:/Users/Tony Zhang/source/repos/UROP/ChemokineGradientSim/TumorDataModel_Reimp.R", echo=TRUE)
source("C:/Users/Tony Zhang/source/repos/UROP/ChemokineGradientSim/TumorDataModel_Reimp.R", echo=TRUE)
source("C:/Users/Tony Zhang/source/repos/UROP/ChemokineGradientSim/TumorDataModel_Reimp.R", echo=TRUE)
source("C:/Users/Tony Zhang/source/repos/UROP/ChemokineGradientSim/TumorDataModel_Reimp.R", echo=TRUE)
source("C:/Users/Tony Zhang/source/repos/UROP/ChemokineGradientSim/TumorDataModel_Reimp.R", echo=TRUE)
